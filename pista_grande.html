<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Pista de Tenis</title>
    <style>
        body {
            margin: 0;
            background-color: black;
            color: white;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            margin: 10px;
            border: 1px solid yellow;
        }

        h1#tituloPista {
            color: yellow;
            text-align: center;
            margin: 10px 0;
        }

        #panelCamara {
            margin: 10px;
        }

        #panelCamara input {
            padding: 5px;
            font-size: 16px;
            width: 80px;
        }

        #panelCamara button {
            padding: 5px 10px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>

<body>

    <canvas id="tenisCanvas"></canvas>

    <script>
        const canvas = document.getElementById("tenisCanvas");
        const ctx = canvas.getContext("2d");

        const escala = 1.50;
        const anchoOriginal = 848;
        const altoOriginal = 512;
        const anchoPistaRealmm = 1097; // pista de dobles

        const escalaReal = (anchoOriginal * escala) / anchoPistaRealmm;

        canvas.width = anchoOriginal * escala;
        canvas.height = altoOriginal * escala;

        const xMin = 228 * escala, xMax = 622 * escala;
        const yDoblesTop = 165 * escala, ySinglesTop = 188 * escala;
        const yCentro = 256 * escala;
        const ySinglesBottom = 323 * escala, yDoblesBottom = 346 * escala;

        const medioX = (xMin + xMax) / 2;

        // Cambiar las líneas de servicio a las nuevas posiciones en X
        const serviceLeftX = 319 * escala;   // Establecer la línea de servicio izquierda en X = 319
        const serviceRightX = 531 * escala;  // Establecer la línea de servicio derecha en X = 531


        //const serviceLeftX = xMin + (xMax - xMin) * 0.25;
        //const serviceRightX = xMin + (xMax - xMin) * 0.75;
        const midServiceY = (ySinglesTop + ySinglesBottom) / 2;

        const camarasDobles = [2, 7, 8, 13, 16, 21, 22, 27, 28, 29, 30, 31, 40, 41, 42, 43];

        const factormmToPx = 60;

        // Líneas de referencia en px (posición en el canvas sin escalar)
        const lineaTopPx = 165;
        const lineaBottomPx = 346;
        const baselineDerechaPx = 622;
        const baselineIzquierdaPx = 228;

        // Funciones de conversión
        function desdeLineaSuperior(mm) {
            const resultado = lineaTopPx - (mm / factormmToPx);
            //console.log(Desde Línea Superior (${mm} mm): ${resultado} px);
            return resultado;
        }

        function desdeLineaInferior(mm) {
            const resultado = lineaBottomPx + (mm / factormmToPx);
            //console.log(Desde Línea Inferior (${mm} mm): ${resultado} px);
            return resultado;
        }

        function desdeBaselineDerecha(mm) {
            const resultado = baselineDerechaPx + (mm / factormmToPx);
            //console.log(Desde Baseline Derecha (${mm} mm): ${resultado} px);
            return resultado;
        }

        function desdeBaselineIzquierda(mm) {
            const resultado = baselineIzquierdaPx - (mm / factormmToPx);
            //console.log(Desde Baseline Izquierda (${mm} mm): ${resultado} px);
            return resultado;
        }


        // Coordenadas en mm (solo necesarias para bloques)
        const y0mm = 4150; // 0 y 2
        const y5mm = 4050; // 5 y 7
        const y14mm = 4050; // 14 y 16
        const y19mm = 4150; // 19 y 21
        const X10mm = 7700; // 10 Y 11
        const X24mm = 7700; // 24 Y 25

        // Definición de bloques
        const bloques = {
            bloque1: {
                cams: [0, 2],
                posicion: [baselineDerechaPx, desdeLineaSuperior(y0mm)],
                offset: [[-10, 0], [10, 0]]
            },
            bloque2: {
                cams: [5, 7],
                posicion: [baselineIzquierdaPx, desdeLineaSuperior(y5mm)],
                offset: [[-10, 0], [10, 0]]
            },
            bloque3: {
                cams: [14, 16],
                posicion: [baselineIzquierdaPx, desdeLineaInferior(y14mm)],
                offset: [[10, 0], [-10, 0]]
            },
            bloque4: {
                cams: [19, 21],
                posicion: [baselineDerechaPx, desdeLineaInferior(y19mm)],
                offset: [[10, 0], [-10, 0]]
            },
            bloque5: {
                cams: [10, 11],
                posicion: [desdeBaselineDerecha(X10mm), 256], // Ajusta la altura aquí
                offset: [[0, -10], [0, 10]]
            },
            bloque6: {
                cams: [24, 25],
                posicion: [desdeBaselineIzquierda(X24mm), 256], // Ajusta la altura aquí
                offset: [[0, 10], [0, -10]]
            }
        };

        // SOLO intercambiamos las posiciones y offsets, NO los IDs
        [bloques.bloque1.posicion, bloques.bloque2.posicion] = [bloques.bloque2.posicion, bloques.bloque1.posicion];
        [bloques.bloque1.offset, bloques.bloque2.offset] = [bloques.bloque2.offset, bloques.bloque1.offset];

        [bloques.bloque3.posicion, bloques.bloque4.posicion] = [bloques.bloque4.posicion, bloques.bloque3.posicion];
        [bloques.bloque3.offset, bloques.bloque4.offset] = [bloques.bloque4.offset, bloques.bloque3.offset];


        // Crear objeto de cámaras
        const camaras = {};

        let camaraSeleccionada = null;

        // Aplica las posiciones de los bloques
        for (const bloque of Object.values(bloques)) {
            const [xBase, yBase] = bloque.posicion;
            //console.log(Posición base del bloque: [${xBase}, ${yBase}]);
            bloque.cams.forEach((camId, i) => {
                const [dx, dy] = bloque.offset[i];
                camaras[camId] = [xBase + dx, yBase + dy];
                //console.log(Cámara ${camId} posición: [${camaras[camId][0]}, ${camaras[camId][1]}]);
            });
        }

        // Coordenadas extra en mm
        const y3mm = 4150;
        const y4mm = 4150;
        const y17mm = 4050;
        const y18mm = 4050;
        const x8mm = 7700;
        const x9mm = 7700;
        const x12mm = 7700;
        const x13mm = 7700;
        const x22mm = 7700;
        const x23mm = 7700;
        const x26mm = 7700;
        const x27mm = 7700;

        // Cámaras fuera de bloques
        Object.assign(camaras, {
            3: [531, desdeLineaSuperior(y3mm)],
            4: [319, desdeLineaSuperior(y4mm)],
            8: [desdeBaselineDerecha(x8mm), 165],
            9: [desdeBaselineDerecha(x9mm), 188],
            12: [desdeBaselineDerecha(x12mm), 323],
            13: [desdeBaselineDerecha(x13mm), 346],
            17: [319, desdeLineaInferior(y17mm)],
            18: [531, desdeLineaInferior(y18mm)],
            22: [desdeBaselineIzquierda(x22mm), 346],
            23: [desdeBaselineIzquierda(x23mm), 323],
            26: [desdeBaselineIzquierda(x26mm), 188],
            27: [desdeBaselineIzquierda(x27mm), 165],
            28: [416, 165],
            29: [400, 165],
            30: [434, 165],
            31: [450, 165],
            32: [416, 188],
            33: [400, 188],
            34: [434, 188],
            35: [450, 188],
            36: [416, 323],
            37: [400, 323],
            38: [434, 323],
            39: [450, 323],
            40: [416, 346],
            41: [400, 346],
            42: [434, 346],
            43: [450, 346]
        });

        // Intercambio de posiciones entre las cámaras 3 y 4
        const tempCam3 = camaras[3];
        camaras[3] = camaras[4];
        camaras[4] = tempCam3;

        // Intercambio de posiciones entre las cámaras 17 y 18
        const tempCam17 = camaras[17];
        camaras[17] = camaras[18];
        camaras[18] = tempCam17;

        const distanciasmm = {
            0: y0mm,
            2: y0mm,
            3: y3mm,
            4: y4mm,
            5: y5mm,
            7: y5mm,
            8: x8mm,
            9: x9mm,
            10: X10mm,
            11: X10mm,
            12: x12mm,
            13: x13mm,
            14: y14mm,
            16: y14mm,
            17: y17mm,
            18: y18mm,
            19: y19mm,
            21: y19mm,
            22: x22mm,
            23: x23mm,
            24: X24mm,
            25: X24mm,
            26: x26mm,
            27: x27mm
        };

        const orientacionCamaras = {
            // Cámaras fijas con óptica 16mm mirando hacia abajo
            0: "down",
            2: "down",
            3: "down",
            4: "down",
            5: "down",
            7: "down",


            // Cámaras fijas con óptica 16mm mirando hacia arriba
            14: "up",
            16: "up",
            17: "up",
            18: "up",
            19: "up",
            21: "up",


            // Cámaras fijas con óptica 16mm mirando hacia izquierda
            8: "left",
            9: "left",
            10: "left",
            11: "left",
            12: "left",
            13: "left",
            28: "left",
            29: "left",
            32: "left",
            33: "left",
            36: "left",
            37: "left",
            40: "left",
            41: "left",


            // Cámaras fijas con óptica 16mm mirando hacia derecha
            22: "right",
            23: "right",
            24: "right",
            25: "right",
            26: "right",
            27: "right",
            30: "right",
            31: "right",
            34: "right",
            35: "right",
            38: "right",
            39: "right",
            42: "right",
            43: "right",



            // Puedes añadir más si es necesario...
        };

        const vectoresOptica16 = [
            [16.7, 3.06], [33.3, 5.87], [50.0, 8.60], [66.7, 11.28], [83.3, 13.92],
            [100.0, 16.53], [116.7, 19.11], [133.3, 21.67], [150.0, 24.22], [166.7, 26.74],
            [183.3, 29.26], [200.0, 31.75], [216.7, 34.24], [233.3, 36.72], [250.0, 39.18],
            [266.7, 41.64], [283.3, 44.09], [300.0, 46.53], [316.7, 48.96], [333.3, 51.38],
            [350.0, 53.80], [366.7, 56.21], [383.3, 58.61], [400.0, 61.01], [416.7, 63.40],
            [433.3, 65.78], [450.0, 68.17], [466.7, 70.54], [483.3, 72.91], [500.0, 75.28],
            [516.7, 77.64]
        ];

        const vectoresOptica25 = [
            [16.7, 1.88], [33.3, 3.68], [50.0, 5.44], [66.7, 7.18], [83.3, 8.91],
            [100.0, 10.62], [116.7, 12.33], [133.3, 14.02], [150.0, 15.71], [166.7, 17.40],
            [183.3, 19.07], [200.0, 20.74], [216.7, 22.41], [233.3, 24.07], [250.0, 25.73],
            [266.7, 27.38], [283.3, 29.03], [300.0, 30.68], [316.7, 32.33], [333.3, 33.97],
            [350.0, 35.61], [366.7, 37.24], [383.3, 38.87], [400.0, 40.50], [416.7, 42.13],
            [433.3, 43.76], [450.0, 45.38], [466.7, 47.00], [483.3, 48.62], [500.0, 50.24],
            [516.7, 51.86]
        ];

        const vectoresOptica35 = [
            [16.7, 1.40], [33.3, 2.72], [50.0, 4.02], [66.7, 5.29], [83.3, 6.56],
            [100.0, 7.81], [116.7, 9.06], [133.3, 10.30], [150.0, 11.53], [166.7, 12.76],
            [183.3, 13.98], [200.0, 15.20], [216.7, 16.41], [233.3, 17.62], [250.0, 18.83],
            [266.7, 20.03], [283.3, 21.23], [300.0, 22.43], [316.7, 23.62], [333.3, 24.82],
            [350.0, 26.01], [366.7, 27.19], [383.3, 28.38], [400.0, 29.56], [416.7, 30.74],
            [433.3, 31.92], [450.0, 33.10], [466.7, 34.28], [483.3, 35.45], [500.0, 36.63],
            [516.7, 37.80]
        ];

        const vectoresOptica50 = [
            [16.7, 0.95], [33.3, 1.85], [50.0, 2.74], [66.7, 3.62], [83.3, 4.48],
            [100.0, 5.35], [116.7, 6.20], [133.3, 7.05], [150.0, 7.90], [166.7, 8.75],
            [183.3, 9.59], [200.0, 10.43], [216.7, 11.26], [233.3, 12.10], [250.0, 12.93],
            [266.7, 13.76], [283.3, 14.58], [300.0, 15.41], [316.7, 16.23], [333.3, 17.06],
            [350.0, 17.88], [366.7, 18.70], [383.3, 19.52], [400.0, 20.33], [416.7, 21.15],
            [433.3, 21.96], [450.0, 22.78], [466.7, 23.59], [483.3, 24.40], [500.0, 25.21],
            [516.7, 26.02]
        ];

        const vectoresOptica75 = [
            [16.7, 0.71], [33.3, 1.36], [50.0, 1.99], [66.7, 2.60], [83.3, 3.21],
            [100.0, 3.81], [116.7, 4.40], [133.3, 4.99], [150.0, 5.58], [166.7, 6.16],
            [183.3, 6.73], [200.0, 7.31], [216.7, 7.88], [233.3, 8.45], [250.0, 9.01],
            [266.7, 9.58], [283.3, 10.14], [300.0, 10.70], [316.7, 11.25], [333.3, 11.81],
            [350.0, 12.36], [366.7, 12.92], [383.3, 13.47], [400.0, 14.02], [416.7, 14.56],
            [433.3, 15.11], [450.0, 15.66], [466.7, 16.20], [483.3, 16.74], [500.0, 17.28],
            [516.7, 17.83]
        ];

        const vectoresOptica100 = [
            [16.7, 0.47], [33.3, 0.93], [50.0, 1.38], [66.7, 1.83], [83.3, 2.27],
            [100.0, 2.71], [116.7, 3.15], [133.3, 3.59], [150.0, 4.02], [166.7, 4.46],
            [183.3, 4.89], [200.0, 5.33], [216.7, 5.76], [233.3, 6.19], [250.0, 6.62],
            [266.7, 7.05], [283.3, 7.47], [300.0, 7.90], [316.7, 8.33], [333.3, 8.75],
            [350.0, 9.18], [366.7, 9.60], [383.3, 10.03], [400.0, 10.45], [416.7, 10.88],
            [433.3, 11.30], [450.0, 11.72], [466.7, 12.14], [483.3, 12.57], [500.0, 12.99],
            [516.7, 13.41]
        ];


        const coloresPorOptica = {
            "16mm": "rgba(255, 105, 180, 0.4)",  // rosa
            "25mm": "rgba(0, 255, 255, 0.4)",    // cian
            "35mm": "rgba(255, 165, 0, 0.4)",    // naranja
            "50mm": "rgba(200, 0, 255, 0.4)",    // lila
            "75mm": "rgba(255, 255, 0, 0.4)",    // amarillo
            "100mm": "rgba(255, 255, 0, 0.4)"    // también amarillo
        };

        function interpolarApertura(distanciaPxEscala1, vectores) {
            for (let i = 1; i < vectores.length; i++) {
                const [d0, a0] = vectores[i - 1];
                const [d1, a1] = vectores[i];
                if (distanciaPxEscala1 <= d1) {
                    const ratio = (distanciaPxEscala1 - d0) / (d1 - d0);
                    return a0 + ratio * (a1 - a0);
                }
            }
            return 0; // fuera de rango
        }

        function dibujarConoVision(camX, camY, direccion = "down", camId = null, optica = "16mm") {
            if (!zonasDisparo[camId] || yActual === null || xActual === null) return;

            let distanciaCanvas = 0;
            switch (direccion) {
                case "down":
                case "up":
                    distanciaCanvas = Math.abs(yActual * escala - camY);
                    break;
                case "left":
                case "right":
                    const xFlip = anchoOriginal - xActual;
                    distanciaCanvas = Math.abs(xFlip * escala - camX);
                    break;
            }

            const distanciaEscala1 = distanciaCanvas / escala;

            const tabla = {
                "16mm": vectoresOptica16,
                "25mm": vectoresOptica25,
                "35mm": vectoresOptica35,
                "50mm": vectoresOptica50,
                "75mm": vectoresOptica75,
                "100mm": vectoresOptica100
            };

            const vectores = tabla[optica];
            if (!vectores) return;

            const aperturaPxEscala1 = interpolarApertura(distanciaEscala1, vectores);
            if (aperturaPxEscala1 === 0) return;

            const aperturaCanvasTotal = aperturaPxEscala1 * escala;
            const aperturaCanvasMitad = aperturaCanvasTotal / 2;

            let base1X, base1Y, base2X, base2Y;
            switch (direccion) {
                case "down":
                    base1X = camX - aperturaCanvasMitad;
                    base2X = camX + aperturaCanvasMitad;
                    base1Y = base2Y = camY + distanciaCanvas;
                    break;
                case "up":
                    base1X = camX - aperturaCanvasMitad;
                    base2X = camX + aperturaCanvasMitad;
                    base1Y = base2Y = camY - distanciaCanvas;
                    break;
                case "right":
                    base1Y = camY - aperturaCanvasMitad;
                    base2Y = camY + aperturaCanvasMitad;
                    base1X = base2X = camX + distanciaCanvas;
                    break;
                case "left":
                    base1Y = camY - aperturaCanvasMitad;
                    base2Y = camY + aperturaCanvasMitad;
                    base1X = base2X = camX - distanciaCanvas;
                    break;
            }

            const aperturaMm = aperturaPxEscala1 * 60;
            const distanciaMm = distanciaEscala1 * 60;
            const distanciaM = distanciaMm / 1000;

            const textoX = (base1X + base2X) / 2;
            const textoY = (base1Y + base2Y) / 2 - 5;

            // 1. Dibujar el cono con color por óptica
            ctx.beginPath();
            ctx.moveTo(camX, camY);
            ctx.lineTo(base1X, base1Y);
            ctx.lineTo(base2X, base2Y);
            ctx.closePath();
            ctx.fillStyle = coloresPorOptica[optica] || "rgba(255, 255, 255, 0.3)";
            ctx.fill();

            // 2. Luego dibujar el texto en blanco (separado)
            ctx.fillStyle = "white";
            ctx.font = `${13 * escala}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";

            ctx.fillText(`Dist: ${distanciaM.toFixed(2)} m`, textoX, textoY - 14);
            ctx.fillText(`Ancho: ${aperturaMm.toFixed(1)} mm`, textoX, textoY);
            ctx.fillText(`(${aperturaPxEscala1.toFixed(1)} px)`, textoX, textoY + 14);


        }

















        // Definir ópticas automáticamente según la rúbrica
        const infoCamaras = {
        };
        for (const [idStr, distancia] of Object.entries(distanciasmm)) {
            const id = parseInt(idStr);

            // Excepción manual
            /*if (id === 13) {
                infoCamaras[id] = { optica: "16mm" }; // o lo que quieras
                continue; // saltar a la siguiente cámara
            }
            if ([13, 17].includes(id)) {
                infoCamaras[id] = { optica: "100mm" };
                continue;
            }*/

            // Grupo 1
            if ([10, 11, 24, 25].includes(id)) {
                infoCamaras[id] = { optica: distancia <= 10000 ? "50mm" : "75mm" };
            }
            // Grupo 2
            else if ([8, 9, 12, 13, 22, 23, 26, 27].includes(id)) {
                infoCamaras[id] = { optica: distancia <= 10000 ? "50mm" : "75mm" };
            }
            // Grupo 3
            else if ([0, 5, 14, 19].includes(id)) {
                infoCamaras[id] = { optica: distancia <= 4500 ? "35mm" : "50mm" };
            }
            // Grupo 4
            else if ([2, 7, 16, 21].includes(id)) {
                infoCamaras[id] = { optica: distancia <= 4500 ? "16mm" : "35mm" };
            }
            // Grupo 5
            else if ([3, 4, 17, 18].includes(id)) {
                infoCamaras[id] = { optica: distancia <= 4500 ? "25mm" : "35mm" };
            }

            // Grupo 6
            [28, 30, 32, 34, 36, 38, 40, 42].forEach(id => {
                infoCamaras[id] = { optica: "16mm" };
            });

            // Grupo 7
            [29, 31, 33, 35, 37, 39, 41, 43].forEach(id => {
                infoCamaras[id] = { optica: "35mm" };
            });


        };


        /*28: [424, 165],
        29: [424, 165],
        30: [424, 165],
        31: [424, 165],
        32: [424, 188],
        33: [424, 188],
        34: [424, 188],
        35: [424, 188],
        36: [424, 323],
        37: [424, 323],
        38: [424, 323],
        39: [424, 323],
        40: [424, 346],
        41: [424, 346],
        42: [424, 346],
        43: [424, 346],*/

        function dibujarPista(titulo = "", xCoord = null, yCoord = null, estado = null, camarasInvolucradas = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.strokeRect(xMin, yDoblesTop, xMax - xMin, yDoblesBottom - yDoblesTop);


            if (xCoord !== null) {
                ctx.fillStyle = "yellow";
                ctx.font = `${45 * escala}px Arial`;
                ctx.textAlign = "right";
                ctx.textBaseline = "top";
                ctx.fillText(`X: ${xCoord}`, canvas.width - 5, 5);
            }

            if (yCoord !== null) {
                ctx.fillStyle = "yellow";
                ctx.font = `${45 * escala}px Arial`;
                ctx.textAlign = "left";
                ctx.textBaseline = "bottom";
                ctx.fillText(`Y: ${yCoord}`, 5, canvas.height - 5);
            }


            ctx.beginPath();
            ctx.moveTo(xMin, ySinglesTop); ctx.lineTo(xMax, ySinglesTop);
            ctx.moveTo(xMin, ySinglesBottom); ctx.lineTo(xMax, ySinglesBottom);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(medioX, yDoblesTop); ctx.lineTo(medioX, yDoblesBottom);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(serviceLeftX, ySinglesTop); ctx.lineTo(serviceLeftX, ySinglesBottom);
            ctx.moveTo(serviceRightX, ySinglesTop); ctx.lineTo(serviceRightX, ySinglesBottom);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(serviceLeftX, midServiceY); ctx.lineTo(serviceRightX, midServiceY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(medioX, ySinglesTop); ctx.lineTo(medioX, ySinglesBottom);
            ctx.stroke();

            if (!isNaN(estado)) aplicarEstado(estado);
            if (camarasInvolucradas.length > 0) senalarCamarasInvolucradas(camarasInvolucradas);
            if (!isNaN(xCoord) && !isNaN(yCoord)) dibujarPunto(xCoord, yCoord);


            dibujarNumerosCuadrantes();
            dibujarCamaras();
        }

        function dibujarNumerosCuadrantes() {
            ctx.fillStyle = "yellow";
            ctx.font = `${55 * escala}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const cx1 = (medioX + serviceRightX) / 2;
            const cx2 = (serviceLeftX + medioX) / 2;
            const cyTop = (ySinglesTop + midServiceY) / 2;
            const cyBottom = (midServiceY + ySinglesBottom) / 2;

            ctx.fillText("1", cx2, cyTop);  // antes 3
            ctx.fillText("3", cx1, cyTop);  // antes 1
            ctx.fillText("2", cx2, cyBottom);  // antes 4
            ctx.fillText("4", cx1, cyBottom);  // antes 2

        }

        function dibujarCamaras() {
            for (const [numStr, [xOrig, yOrig]] of Object.entries(camaras)) {
                const num = parseInt(numStr);
                const color = camarasDobles.includes(num) ? "steelblue" : "purple";

                const x = xOrig * escala;
                const y = yOrig * escala;

                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.arc(x, y, 8 * escala, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = "white";
                ctx.font = `${15 * escala}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(num, x, y);
            }

            if (camaraSeleccionada !== null) {
                const optica = infoCamaras[camaraSeleccionada]?.optica || "16mm";
                const orientacion = orientacionCamaras[camaraSeleccionada] || "down";

                const camarasRed = [28, 29, 30, 31, 32, 33, 34, 35,
                    36, 37, 38, 39, 40, 41, 42, 43];

                const camarasPuntoMedio = [0, 2, 5, 7, 14, 16, 19, 21];

                const camarasPuntoMedioEspecial = [
                    [10, 11],
                    [24, 25]
                ];

                let xOrigen, yOrigen;

                // Por defecto: origen en la cámara misma
                [xOrigen, yOrigen] = camaras[camaraSeleccionada].map(v => v * escala);

                // Si es cámara de red: origen en el medio de la red
                if (camarasRed.includes(camaraSeleccionada)) {
                    xOrigen = medioX;
                }

                // Si es par especial (10-11 o 24-25): usar el centro de sus posiciones
                for (const grupo of camarasPuntoMedioEspecial) {
                    if (grupo.includes(camaraSeleccionada)) {
                        const [cx1, cy1] = camaras[grupo[0]];
                        const [cx2, cy2] = camaras[grupo[1]];
                        xOrigen = ((cx1 + cx2) / 2) * escala;
                        yOrigen = ((cy1 + cy2) / 2) * escala;
                        break; // Solo un grupo coincide
                    }
                }

                // Punto medio para pares normales
                if (camarasPuntoMedio.includes(camaraSeleccionada)) {
                    const pareja = camarasPuntoMedio.find(id =>
                        id !== camaraSeleccionada && Math.abs(id - camaraSeleccionada) === 2
                    );
                    if (pareja !== undefined && camaras[pareja]) {
                        const [x1, y1] = camaras[camaraSeleccionada];
                        const [x2, y2] = camaras[pareja];
                        xOrigen = ((x1 + x2) / 2) * escala;
                        yOrigen = ((y1 + y2) / 2) * escala;
                    }
                }

                // ✅ Mostrar SOLO la info de la cámara seleccionada en el origen
                mostrarInfoCamara(camaraSeleccionada, xOrigen, yOrigen);

                // ✅ Dibujar cono desde ese origen
                dibujarConoVision(xOrigen, yOrigen, orientacion, camaraSeleccionada, optica);
            }
        }


        // Llamar a la función para dibujar la pista
        dibujarPista();

        ///////////////////////////


        ///////////////////////////////
        function resaltarZona(x1, y1, x2, y2) {
            ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
            ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }

        function obtenerTituloPorEstado(estado) {
            switch (estado) {
                case 0: return "Area Simples";
                case 1: return "Area Dobles";
                case 2: return "Saque 1 a 4";
                case 3: return "Saque 2 a 3";
                case 4: return "Saque 3 a 2";
                case 5: return "Saque 4 a 1";
                default: return "Pista de Tenis";
            }
        }


        function aplicarEstado(estado) {
            switch (estado) {
                case 0: // Simples
                    resaltarZona(xMin, ySinglesTop, xMax, ySinglesBottom);
                    break;
                case 1: // Dobles
                    resaltarZona(xMin, yDoblesTop, xMax, yDoblesBottom);
                    break;
                case 2: // Saque 1 a 4
                    resaltarZona(medioX, midServiceY, serviceRightX, ySinglesBottom);
                    //resaltarZona(serviceLeftX, ySinglesTop, medioX, midServiceY);
                    break;
                case 3: // Saque 2 a 3
                    resaltarZona(medioX, ySinglesTop, serviceRightX, midServiceY);
                    break;
                case 4: // Saque 3 a 2
                    resaltarZona(serviceLeftX, midServiceY, medioX, ySinglesBottom);
                    break;
                case 5: // Saque 4 a 1
                    resaltarZona(serviceLeftX, ySinglesTop, medioX, midServiceY);
                    //resaltarZona(medioX, midServiceY, serviceRightX, ySinglesBottom);
                    break;
            }
        }



        function getParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const x = parseInt(urlParams.get("x"));
            const y = parseInt(urlParams.get("y"));
            const estado = parseInt(urlParams.get("estado"));
            const camarasStr = urlParams.get("camaras");
            const camarasInvolucradas = camarasStr ? camarasStr.split(",").map(num => parseInt(num)) : [];
            return [x, y, estado, camarasInvolucradas];
        }




        const zonasDisparo = {
            0: [610, 634, 179, 355],
            2: [610, 634, 156, 254],
            3: [519, 542, 179, 332],
            4: [307, 331, 179, 332],
            5: [216, 240, 179, 355],
            7: [216, 240, 156, 254],
            8: [216, 423, 156, 174],
            9: [216, 423, 179, 197],
            10: [307, 423, 247, 265],
            11: [307, 423, 247, 265],
            12: [216, 423, 314, 332],
            13: [216, 423, 337, 355],
            14: [216, 240, 156, 332],
            16: [216, 240, 255, 355],
            17: [307, 331, 179, 332],
            18: [519, 542, 179, 332],
            19: [610, 634, 156, 332],
            21: [610, 634, 255, 355],
            22: [425, 634, 337, 355],
            23: [425, 634, 314, 332],
            24: [425, 542, 247, 265],
            25: [425, 542, 247, 265],
            26: [425, 634, 179, 197],
            27: [425, 634, 156, 174],
            28: [425, 609, 156, 174],
            29: [469, 634, 156, 174],
            30: [241, 423, 156, 174],
            31: [216, 379, 156, 174],
            32: [425, 609, 179, 197],
            33: [469, 634, 179, 197],
            34: [241, 423, 179, 197],
            35: [216, 379, 179, 197],
            36: [425, 609, 314, 332],
            37: [469, 634, 314, 332],
            38: [241, 423, 314, 332],
            39: [216, 379, 314, 332],
            40: [425, 609, 337, 355],
            41: [469, 634, 337, 355],
            42: [241, 423, 337, 355],
            43: [216, 379, 337, 355]
        };

        function senalarCamarasInvolucradas(listaNumeros) {
            for (const numero of listaNumeros) {
                if (!(numero in camaras)) continue;
                const [x, y] = camaras[numero].map(coord => coord * escala);

                // Dibuja círculo verde alrededor de la cámara
                ctx.beginPath();
                ctx.strokeStyle = "green";
                ctx.lineWidth = 4;
                ctx.arc(x, y, 10 * escala, 0, Math.PI * 2);
                ctx.stroke();

                // Dibuja la zona de disparo resaltada
                if (numero in zonasDisparo) {

                    const [x_min_orig, x_max_orig, y_min, y_max] = zonasDisparo[numero];

                    // Invertir las coordenadas en X:
                    const x_min = anchoOriginal - x_max_orig;
                    const x_max = anchoOriginal - x_min_orig;

                    // Escalar después
                    const rectX = x_min * escala;
                    const rectY = y_min * escala;
                    const rectWidth = (x_max - x_min) * escala;
                    const rectHeight = (y_max - y_min) * escala;

                    ctx.fillStyle = "rgba(0, 255, 0, 0.3)"; // verde transparente
                    ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
                }
            }
        }


        function mostrarInfoCamara(id, x, y) {
            const info = infoCamaras[id] || {};
            const optica = info.optica || "desconocida";

            let distancia = "desconocida";
            if (id in distanciasmm) {
                distancia = (distanciasmm[id] / 1000).toFixed(2) + " m";
            }

            //Background trasparente Info
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(x + 10, y - 60, 100, 60);

            ctx.fillStyle = "white";
            ctx.font = `${8 * escala}px Arial`;  // <-- BACKTICKS aquí
            ctx.textAlign = "left";
            ctx.textBaseline = "top";

            // Mostrar nombre de cámara
            ctx.fillText(`Cam ${id}`, x + 15, y - 55);  // <-- BACKTICKS aquí

            // Círculo con color óptica
            const color = coloresPorOptica[optica] || "white";
            ctx.beginPath();
            ctx.arc(x + 10, y - 26, 5, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();

            // Texto óptica
            ctx.fillStyle = "white";
            ctx.fillText(`Óptica: ${optica}`, x + 25, y - 35);  // <-- BACKTICKS aquí

            if (distancia !== "desconocida") {
                ctx.fillText(`Distancia: ${distancia}`, x + 15, y - 15);  // <-- BACKTICKS aquí
            }

        }



        /////////////////////////////////7


        /* function dibujarPunto(x, y) {
             const diametroPelotamm = 6.6;
             const radius = (diametroPelotamm / 2) * escalaReal;
             const xInvertido = anchoOriginal - x;
             const yNormal = y;  // sin invertir
 
             ctx.beginPath();
             ctx.fillStyle = "red";
             ctx.arc(xInvertido * escala, yNormal * escala, radius, 0, Math.PI * 2);
             ctx.fill();
         }*/

        //////////////////////////////////////////////////





        // NUEVA FUNCIÓN: Señalar cámara indicada
        function senalarCamara() {
            const numero = parseInt(document.getElementById("inputCamara").value);
            if (!camaras[numero]) {
                alert("Número de cámara no válido.");
                return;
            }

            const [x, y] = camaras[numero].map(coord => coord * escala);

            // Dibuja círculo amarillo alrededor de la cámara
            ctx.beginPath();
            ctx.strokeStyle = "green";
            ctx.lineWidth = 5;
            ctx.arc(x, y, 20 * escala, 0, Math.PI * 2);
            ctx.stroke();
        }



        // Llamar a la función para dibujar la pista con la pelota
        window.onload = () => {
            const [x, y, estado, camarasInvolucradas] = getParams();
            const titulo = obtenerTituloPorEstado(estado);
            dibujarPista(titulo, x, y);
            if (!isNaN(estado)) aplicarEstado(estado);
            if (camarasInvolucradas.length > 0) senalarCamarasInvolucradas(camarasInvolucradas);
            if (!isNaN(x) && !isNaN(y)) dibujarPunto(x, y); // Mover esto al final
        };

        let estadoActual = null;
        let xActual = null;
        let yActual = null;
        let camarasInvolucradasActuales = [];


        canvas.addEventListener("click", function (event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (event.clientX - rect.left);  // en coordenadas canvas
            const mouseY = (event.clientY - rect.top);   // en coordenadas canvas

            [xActual, yActual, estadoActual, camarasInvolucradasActuales] = getParams();

            const clicCamaraId = detectarCamaraClick(mouseX, mouseY);

            camaraSeleccionada = (clicCamaraId === camaraSeleccionada) ? null : clicCamaraId;

            const titulo = obtenerTituloPorEstado(estadoActual);
            dibujarPista(titulo, xActual, yActual, estadoActual, camarasInvolucradasActuales);
        });


        function detectarCamaraClick(mouseX, mouseY) {
            for (const [idStr, [cx, cy]] of Object.entries(camaras)) {
                const id = parseInt(idStr);
                const dx = mouseX - (cx * escala);
                const dy = mouseY - (cy * escala);
                const distancia = Math.sqrt(dx * dx + dy * dy);

                if (distancia < 10 * escala) {
                    return id;
                }
            }
            return null;
        }


        /////////////////////////////////7


        function dibujarPunto(x, y) {
            const diametroPelotamm = 6.6;
            const radius = (diametroPelotamm / 2) * escalaReal;
            const xInvertido = anchoOriginal - x;
            const yNormal = y;  // sin invertir

            ctx.beginPath();
            ctx.fillStyle = "red";
            ctx.arc(xInvertido * escala, yNormal * escala, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        //////////////////////////////////////////////////



    </script>
</body>

</html>